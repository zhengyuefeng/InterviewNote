## 一、java垃圾回收标记算法

### （1）自动垃圾回收

​	自动垃圾回收是一种在堆内存中找出哪些对象在被使用，还有哪些对象没被使用，并且将后者删掉的机制。所谓使用中的对象（已引用对象），指的是程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。

### （2）引用计数法

![1563000488901](assets/1563000488901.png)

优缺点：

![1563000510877](assets/1563000510877.png)

```java
　　public class ReferenceCountingGC {
　　
        public Object instance = null;
        public static void testGC(){

            ReferenceCountingGC objA = 
                new ReferenceCountingGC ();
            ReferenceCountingGC objB = 
                new ReferenceCountingGC ();

            // 对象之间相互循环引用，对象objA和objB之间的引用计数永远不可能为 0
            objB.instance = objA;
            objA.instance = objB;
            
            objA = null;
            objB = null;
            System.gc();
    }
}
```



### （3）可达性分析法

![1563000917585](assets/1563000917585.png)

#### （4）哪些对象可以作为GC Root的对象

- 虚拟机栈(栈帧中的局部变量表)中引用的对象；
- 本地方法栈中Native方法引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；

## 二、java垃圾回收算法

### 1、**标记清除算法**

![1563001261795](assets/1563001261795.png)

算法流程：

​	标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收。

![1563001431531](assets/1563001431531.png)

标记-清除算法的主要不足有两个：

**效率问题：**标记和清除两个过程的效率都不高;

**空间问题：**标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 2、复制算法（copying）

​	复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

![1563001588283](assets/1563001588283.png)

![1563001635696](assets/1563001635696.png)

​	事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。

​	实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 (如下图所示)，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。

​	复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

### 3、标记整理算法

​	标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示。

![1563001824963](assets/1563001824963.png)

​	标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示意图如下：

![1563001855823](assets/1563001855823.png)

### 4、分代收集算法

#### （1）为什么需要分代垃圾收集？

​	逐一标记和压缩 Java 虚拟机里的所有对象非常低效：分配的对象越多，垃圾回收需时就越久。根据统计，大部分的对象，其实用没多久就不用了。大部分对象其实都挺短命的。

![1563001996779](assets/1563001996779.png)

![1563002091698](assets/1563002091698.png)

![1563002114514](assets/1563002114514.png)

#### （2）GC的分类

![1563002174815](assets/1563002174815.png)

#### （3）年轻代

![1563002251827](assets/1563002251827.png)



回收过程：

eden区存活的对象被复制到S0区中，

![1563002325475](assets/1563002325475.png)

对eden区和S0区存活的对象进行回收，把存活的对象复制到S1中

![1563002401591](assets/1563002401591.png)

#### （4）对象如何晋升到老年代

![1563002525483](assets/1563002525483.png)

#### （5）老年代

 ![1563002564813](assets/1563002564813.png)

![1563002593528](assets/1563002593528.png)

![1563002642884](assets/1563002642884.png)

## 三、java垃圾收集器

![1563002767082](assets/1563002767082.png)

![1563002805478](assets/1563002805478.png)

![1563002861049](assets/1563002861049.png)

### 1、常见的垃圾收集器

![1563002899865](assets/1563002899865.png)

### 2、新生代垃圾收集器

![1563002962350](assets/1563002962350.png)

![1563003025851](assets/1563003025851.png)

![1563003059275](assets/1563003059275.png)

### 3、老年代垃圾收集器

![1563003089661](assets/1563003089661.png)

![1563003118417](assets/1563003118417.png)

![1563003142875](assets/1563003142875.png)

![1563003172852](assets/1563003172852.png)

![1563003184201](assets/1563003184201.png)

### 4、G1

![1563003298077](assets/1563003298077.png)

![1563003317422](assets/1563003317422.png)

![1563003373323](assets/1563003373323.png)



## 四、GC相关的面试题

### 1、object的finalize()方法的作用与c++的析构函数作用对比

![1563007229726](assets/1563007229726.png)

### 2、强引用、软引用、弱引用、虚引用

![1563007291243](assets/1563007291243.png)

![1563007352382](assets/1563007352382.png)

![1563007377666](assets/1563007377666.png)

![1563007403176](assets/1563007403176.png)

![1563007420494](assets/1563007420494.png)







